CCS PCM C Compiler, Version 5.015, 5967               15-Thg11-17 11:07

               Filename:   A:\PIC_CCS\7SEG_Demo\7SEG_Demo.lst

               ROM used:   492 words (6%)
                           Largest free fragment is 2048
               RAM used:   37 (10%) at main() level
                           50 (14%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   16B
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   054
.................... #include <7SEG_Demo.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  DATA 54,34
0052:  DATA 61,37
0053:  DATA 00,00
*
0113:  MOVF   0B,W
0114:  MOVWF  40
0115:  BCF    0B.7
0116:  BSF    03.5
0117:  BSF    03.6
0118:  BSF    0C.7
0119:  BSF    0C.0
011A:  NOP
011B:  NOP
011C:  BCF    03.5
011D:  BCF    03.6
011E:  BTFSC  40.7
011F:  BSF    0B.7
0120:  BSF    03.6
0121:  MOVF   0C,W
0122:  ANDLW  7F
0123:  BTFSC  03.2
0124:  GOTO   167
0125:  BCF    03.6
0126:  MOVWF  40
0127:  BSF    03.6
0128:  MOVF   0D,W
0129:  BCF    03.6
012A:  MOVWF  41
012B:  BSF    03.6
012C:  MOVF   0F,W
012D:  BCF    03.6
012E:  MOVWF  42
012F:  MOVF   40,W
0130:  MOVWF  43
0131:  CALL   10C
0132:  MOVF   41,W
0133:  BSF    03.6
0134:  MOVWF  0D
0135:  BCF    03.6
0136:  MOVF   42,W
0137:  BSF    03.6
0138:  MOVWF  0F
0139:  BCF    03.6
013A:  MOVF   0B,W
013B:  MOVWF  43
013C:  BCF    0B.7
013D:  BSF    03.5
013E:  BSF    03.6
013F:  BSF    0C.7
0140:  BSF    0C.0
0141:  NOP
0142:  NOP
0143:  BCF    03.5
0144:  BCF    03.6
0145:  BTFSC  43.7
0146:  BSF    0B.7
0147:  BSF    03.6
0148:  RLF    0C,W
0149:  RLF    0E,W
014A:  ANDLW  7F
014B:  BTFSC  03.2
014C:  GOTO   167
014D:  BCF    03.6
014E:  MOVWF  40
014F:  BSF    03.6
0150:  MOVF   0D,W
0151:  BCF    03.6
0152:  MOVWF  41
0153:  BSF    03.6
0154:  MOVF   0F,W
0155:  BCF    03.6
0156:  MOVWF  42
0157:  MOVF   40,W
0158:  MOVWF  43
0159:  CALL   10C
015A:  MOVF   41,W
015B:  BSF    03.6
015C:  MOVWF  0D
015D:  BCF    03.6
015E:  MOVF   42,W
015F:  BSF    03.6
0160:  MOVWF  0F
0161:  INCF   0D,F
0162:  BTFSC  03.2
0163:  INCF   0F,F
0164:  BCF    03.6
0165:  GOTO   113
0166:  BSF    03.6
0167:  BCF    03.6
0168:  BCF    0A.3
0169:  BCF    0A.4
016A:  GOTO   1B7 (RETURN)
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
018D:  BCF    03.6
018E:  CLRF   2B
018F:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=4000000) 
*
0066:  MOVLW  46
0067:  MOVWF  04
0068:  BCF    03.7
0069:  MOVF   00,W
006A:  BTFSC  03.2
006B:  GOTO   07A
006C:  MOVLW  01
006D:  MOVWF  78
006E:  CLRF   77
006F:  DECFSZ 77,F
0070:  GOTO   06F
0071:  DECFSZ 78,F
0072:  GOTO   06E
0073:  MOVLW  4A
0074:  MOVWF  77
0075:  DECFSZ 77,F
0076:  GOTO   075
0077:  GOTO   078
0078:  DECFSZ 00,F
0079:  GOTO   06C
007A:  RETURN
....................  
.................... #use rs232(baud=9600,xmit=pin_c6,rcv=pin_c7) 
.................... //#include <A:\PIC_CCS\7SEG\My_7seg.h> 
.................... //#include <A:\PIC_CCS\Keypad\MyKeypad.h> 
.................... #include <A:\PIC_CCS\LCD\MyLCD.h> 
.................... /******************************************** 
.................... * LCD Library 
.................... * Header file "MyLCD.h" 
.................... ********************************************/ 
.................... #INCLUDE <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use fast_io(d) 
....................  
.................... #define LCD_RS       PIN_D1 
.................... #define LCD_RW       PIN_D2 
.................... #define LCD_E        PIN_D3 
.................... #define LCD_D4       PIN_D4 
.................... #define LCD_D5       PIN_D5 
.................... #define LCD_D6       PIN_D6 
.................... #define LCD_D7       PIN_D7 
.................... #define LCD_DIR      set_tris_d 
.................... #define LCD_DIR1      get_tris_d 
.................... //char str[15]; 
.................... void LCDInit(); //Khoi dong LCD 
.................... void LCDMode4Bit(); //Chon LCD hoat dong LCD o che do 4 bit 
.................... void LCDWriteByte(unsigned char ch); 
.................... void LCDWriteData(unsigned char dt); 
.................... void LCDWriteCommand(unsigned char dt); 
.................... void LCDLatchData(); 
.................... void LCDClear(); 
.................... void LCDMove(unsigned char y, unsigned char x); 
.................... void LCDPutChar(unsigned int ch); 
.................... void LCDPrint(char y, char x, char* str);   //In chuoi ky tu str tai dong x, cot y 
.................... void LCDPrintNumber(char y, char x, int num); //Hien thi so nguyen num tai dong x, cot y 
.................... void LCDPrintFNumber(char y, char x, float fnum, char f); //Hien thi so thuc fnum o dong x cot y 
.................... void LCDcreateChar(char ch,char* str); 
.................... /******************************************** 
.................... * Include source file 
.................... ********************************************/ 
.................... #include "MyLCD.c" 
.................... /******************************************** 
.................... * LCD Library 
.................... * Source file "MyLCD.c" 
.................... ********************************************/ 
.................... void LCDInit() 
....................    { 
....................       LCD_DIR(0x00); 
*
00DD:  MOVLW  00
00DE:  BSF    03.5
00DF:  MOVWF  08
....................       //__delay_ms(200); 
....................       LCDMode4Bit(); 
....................       LCDWriteCommand(0x28); 
*
00E8:  MOVLW  28
00E9:  MOVWF  43
00EA:  CALL   0D8
....................       LCDWriteCommand(0x0C); 
00EB:  MOVLW  0C
00EC:  MOVWF  43
00ED:  CALL   0D8
....................       LCDWriteCommand(0x06); 
00EE:  MOVLW  06
00EF:  MOVWF  43
00F0:  CALL   0D8
00F1:  BCF    0A.3
00F2:  BCF    0A.4
00F3:  GOTO   1AB (RETURN)
....................    } 
.................... void LCDMode4Bit() 
....................    { 
....................       output_bit(LCD_RS,0); 
*
00E0:  BCF    03.5
00E1:  BCF    08.1
....................       output_bit(LCD_RW,0); 
00E2:  BCF    08.2
....................       output_bit(LCD_D4,0); 
00E3:  BCF    08.4
....................       output_bit(LCD_D5,1); 
00E4:  BSF    08.5
....................       output_bit(LCD_D6,0); 
00E5:  BCF    08.6
....................       output_bit(LCD_D7,0); 
00E6:  BCF    08.7
....................       LCDLatchData(); 
00E7:  CALL   07B
....................    } 
.................... void LCDWriteByte(unsigned char ch) 
....................    { 
....................       output_bit(LCD_D7,(ch>>7)&0x01); 
*
0081:  CLRF   77
0082:  BTFSC  45.7
0083:  BSF    77.0
0084:  MOVF   77,W
0085:  ANDLW  01
0086:  BTFSS  03.2
0087:  GOTO   08A
0088:  BCF    08.7
0089:  GOTO   08B
008A:  BSF    08.7
....................       output_bit(LCD_D6,(ch>>6)&0x01); 
008B:  SWAPF  45,W
008C:  MOVWF  77
008D:  RRF    77,F
008E:  RRF    77,F
008F:  MOVLW  03
0090:  ANDWF  77,F
0091:  MOVF   77,W
0092:  ANDLW  01
0093:  BTFSS  03.2
0094:  GOTO   097
0095:  BCF    08.6
0096:  GOTO   098
0097:  BSF    08.6
....................       output_bit(LCD_D5,(ch>>5)&0x01); 
0098:  SWAPF  45,W
0099:  MOVWF  77
009A:  RRF    77,F
009B:  MOVLW  07
009C:  ANDWF  77,F
009D:  MOVF   77,W
009E:  ANDLW  01
009F:  BTFSS  03.2
00A0:  GOTO   0A3
00A1:  BCF    08.5
00A2:  GOTO   0A4
00A3:  BSF    08.5
....................       output_bit(LCD_D4,(ch>>4)&0x01); 
00A4:  SWAPF  45,W
00A5:  MOVWF  77
00A6:  MOVLW  0F
00A7:  ANDWF  77,F
00A8:  MOVF   77,W
00A9:  ANDLW  01
00AA:  BTFSS  03.2
00AB:  GOTO   0AE
00AC:  BCF    08.4
00AD:  GOTO   0AF
00AE:  BSF    08.4
....................       LCDLatchData(); 
00AF:  CALL   07B
....................       output_bit(LCD_D7,(ch>>3)&0x01); 
00B0:  RRF    45,W
00B1:  MOVWF  77
00B2:  RRF    77,F
00B3:  RRF    77,F
00B4:  MOVLW  1F
00B5:  ANDWF  77,F
00B6:  MOVF   77,W
00B7:  ANDLW  01
00B8:  BTFSS  03.2
00B9:  GOTO   0BC
00BA:  BCF    08.7
00BB:  GOTO   0BD
00BC:  BSF    08.7
....................       output_bit(LCD_D6,(ch>>2)&0x01); 
00BD:  RRF    45,W
00BE:  MOVWF  77
00BF:  RRF    77,F
00C0:  MOVLW  3F
00C1:  ANDWF  77,F
00C2:  MOVF   77,W
00C3:  ANDLW  01
00C4:  BTFSS  03.2
00C5:  GOTO   0C8
00C6:  BCF    08.6
00C7:  GOTO   0C9
00C8:  BSF    08.6
....................       output_bit(LCD_D5,(ch>>1)&0x01); 
00C9:  BCF    03.0
00CA:  RRF    45,W
00CB:  ANDLW  01
00CC:  BTFSS  03.2
00CD:  GOTO   0D0
00CE:  BCF    08.5
00CF:  GOTO   0D1
00D0:  BSF    08.5
....................       output_bit(LCD_D4,ch&0x01); 
00D1:  BTFSC  45.0
00D2:  GOTO   0D5
00D3:  BCF    08.4
00D4:  GOTO   0D6
00D5:  BSF    08.4
....................       LCDLatchData(); 
00D6:  CALL   07B
00D7:  RETURN
....................    } 
.................... void LCDWriteData(unsigned char dt) 
....................    { 
....................       output_bit(LCD_RS,1); 
*
010E:  BSF    08.1
....................       //LCD_RW=0; 
....................       LCDWriteByte(dt); 
010F:  MOVF   44,W
0110:  MOVWF  45
0111:  CALL   081
....................    } 
.................... void LCDWriteCommand(unsigned char dt) 
....................    { 
....................       output_bit(LCD_RS,0); 
*
00D8:  BCF    08.1
....................       //LCD_RW=0; 
....................       LCDWriteByte(dt); 
00D9:  MOVF   43,W
00DA:  MOVWF  45
00DB:  CALL   081
00DC:  RETURN
....................    } 
.................... void LCDLatchData() 
....................    { 
....................       //LCD_RW=0; 
....................       output_bit(LCD_E,1); 
*
007B:  BSF    08.3
....................       output_bit(LCD_E,0); 
007C:  BCF    08.3
....................       delay_ms(2); 
007D:  MOVLW  02
007E:  MOVWF  46
007F:  CALL   066
0080:  RETURN
....................    } 
.................... void LCDClear() 
....................    { 
....................       LCDWriteCommand(0x01); 
*
00F4:  MOVLW  01
00F5:  MOVWF  43
00F6:  CALL   0D8
00F7:  BCF    0A.3
00F8:  BCF    0A.4
00F9:  GOTO   1AC (RETURN)
....................    } 
.................... void LCDMove(unsigned char y, unsigned char x) 
....................    { 
....................       unsigned int Ad; 
....................       Ad = 64*(y-1)+(x-1)+0x80; 
00FA:  MOVLW  01
00FB:  SUBWF  40,W
00FC:  MOVWF  77
00FD:  SWAPF  77,W
00FE:  MOVWF  43
00FF:  RLF    43,F
0100:  RLF    43,F
0101:  MOVLW  C0
0102:  ANDWF  43,F
0103:  MOVLW  01
0104:  SUBWF  41,W
0105:  ADDWF  43,W
0106:  ADDLW  80
0107:  MOVWF  42
....................       LCDWriteCommand(Ad); 
0108:  MOVF   42,W
0109:  MOVWF  43
010A:  CALL   0D8
010B:  RETURN
....................    } 
.................... void LCDPutChar(unsigned int ch) 
....................    { 
....................       LCDWriteData(ch); 
010C:  MOVF   43,W
010D:  MOVWF  44
*
0112:  RETURN
....................    } 
.................... void LCDPrint(char y, char x, char *str) 
....................    { 
....................       LCDMove(y,x); 
....................       while(*str) 
....................          { 
....................             LCDPutChar(*str); 
....................             str++; 
....................          } 
....................    } 
.................... void LCDPrintNumber(char y, char x, int num) 
....................    { 
....................       char str[7]; 
....................       sprintf(str,"%d",num); 
....................       LCDPrint(y,x,str); 
....................    } 
.................... void LCDPrintFNumber(char y, char x, float fnum, char f){ 
....................    char i,dem[10]; 
....................    char *str1; 
....................    sprintf(dem,"%4.2f",fnum); 
....................    str1 = strtok(dem, ' '); 
....................    for(i=0;i<15;i++){ 
....................       if(str1[i] == '.') break; 
....................    } 
....................    i = (i+f+1); 
....................    str1[i] = ' '; 
....................    i++; 
....................    while(str1[i]){ 
....................       str1[i] = ' '; 
....................       i++; 
....................    } 
....................    LCDPrint(y,x,str1); 
.................... } 
.................... void LCDcreateChar(char ch,char* str){ 
....................    ch &= 0x7; 
....................    LCDWriteCommand(0x40|(ch<<3)); 
....................    for (int i=0; i<8; i++) { 
....................       LCDPutChar(str[i]); 
....................    } 
.................... } 
....................  
....................  
....................  
.................... //#include <A:\PIC_CCS\Stepper\MyStepper.h> 
.................... //#include <A:\PIC_CCS\DHT\My_DHT.h> 
.................... //#include <A:\PIC_CCS\Homephone\Homephone.h> 
....................  
....................  
....................  
....................  
....................  
.................... char receString[16]; 
....................  
.................... void main() 
*
016B:  MOVF   03,W
016C:  ANDLW  1F
016D:  MOVWF  03
016E:  BSF    03.5
016F:  BSF    03.6
0170:  BCF    07.3
0171:  MOVLW  19
0172:  BCF    03.6
0173:  MOVWF  19
0174:  MOVLW  A6
0175:  MOVWF  18
0176:  MOVLW  90
0177:  BCF    03.5
0178:  MOVWF  18
0179:  CLRF   2E
017A:  CLRF   2D
017B:  MOVLW  FF
017C:  MOVWF  3F
017D:  BSF    03.5
017E:  BSF    03.6
017F:  MOVF   09,W
0180:  ANDLW  C0
0181:  MOVWF  09
0182:  BCF    03.6
0183:  BCF    1F.4
0184:  BCF    1F.5
0185:  MOVLW  00
0186:  BSF    03.6
0187:  MOVWF  08
0188:  BCF    03.5
0189:  CLRF   07
018A:  CLRF   08
018B:  CLRF   09
018C:  BCF    03.7
.................... { 
....................    output_low(PIN_C1);   // Set CCP2 output low  
*
0190:  BCF    3F.1
0191:  MOVF   3F,W
0192:  BSF    03.5
0193:  MOVWF  07
0194:  BCF    03.5
0195:  BCF    07.1
....................    output_low(PIN_C2);   // Set CCP1 output low  
0196:  BCF    3F.2
0197:  MOVF   3F,W
0198:  BSF    03.5
0199:  MOVWF  07
019A:  BCF    03.5
019B:  BCF    07.2
....................    setup_ccp1(CCP_PWM);  // Configure CCP1 as a PWM  
019C:  BCF    3F.2
019D:  MOVF   3F,W
019E:  BSF    03.5
019F:  MOVWF  07
01A0:  BCF    03.5
01A1:  BCF    07.2
01A2:  MOVLW  0C
01A3:  MOVWF  17
01A4:  BSF    03.5
01A5:  CLRF   1B
01A6:  CLRF   1C
01A7:  MOVLW  01
01A8:  MOVWF  1D
....................    LCDInit(); 
01A9:  BCF    03.5
01AA:  GOTO   0DD
....................    LCDClear(); 
01AB:  GOTO   0F4
....................    LCDMove(1, 1); 
01AC:  MOVLW  01
01AD:  MOVWF  40
01AE:  MOVWF  41
01AF:  CALL   0FA
....................    printf(LCDPutChar, "%s", "Than"); 
01B0:  MOVLW  51
01B1:  BSF    03.6
01B2:  MOVWF  0D
01B3:  MOVLW  00
01B4:  MOVWF  0F
01B5:  BCF    03.6
01B6:  GOTO   113
....................    setup_timer_2 (T2_DIV_BY_16, 130, 10); 
01B7:  MOVLW  48
01B8:  MOVWF  78
01B9:  IORLW  06
01BA:  MOVWF  12
01BB:  MOVLW  82
01BC:  BSF    03.5
01BD:  MOVWF  12
....................    set_pwm1_duty(10); 
01BE:  MOVLW  0A
01BF:  BCF    03.5
01C0:  MOVWF  15
....................    enable_interrupts(GLOBAL); 
01C1:  MOVLW  C0
01C2:  IORWF  0B,F
....................    enable_interrupts(INT_RDA); 
01C3:  BSF    03.5
01C4:  BSF    0C.5
....................    //LCDPutChar('A'); 
....................    while(TRUE) 
....................    {   
....................       putchar('H');  
01C5:  MOVLW  48
01C6:  BCF    03.5
01C7:  BTFSS  0C.4
01C8:  GOTO   1C7
01C9:  MOVWF  19
....................        
....................       LCDMove(2, 1); 
01CA:  MOVLW  02
01CB:  MOVWF  40
01CC:  MOVLW  01
01CD:  MOVWF  41
01CE:  CALL   0FA
....................       if(receString[0] == 'M'){ 
01CF:  MOVF   2F,W
01D0:  SUBLW  4D
01D1:  BTFSS  03.2
01D2:  GOTO   1D9
....................          set_pwm1_duty(receString[1]); 
01D3:  MOVF   30,W
01D4:  MOVWF  15
....................          putchar('1'); 
01D5:  MOVLW  31
01D6:  BTFSS  0C.4
01D7:  GOTO   1D6
01D8:  MOVWF  19
....................       } 
....................       if(receString[0] == 'D'){ 
01D9:  MOVF   2F,W
01DA:  SUBLW  44
01DB:  BTFSS  03.2
01DC:  GOTO   1E6
....................          //LCDPrint(2, 1, receString); 
....................          LCDPutChar(receString[1]); 
01DD:  MOVF   30,W
01DE:  MOVWF  43
01DF:  CALL   10C
....................          LCDPutChar(receString[2]);  
01E0:  MOVF   31,W
01E1:  MOVWF  43
01E2:  CALL   10C
....................          LCDPutChar(receString[3]);   
01E3:  MOVF   32,W
01E4:  MOVWF  43
01E5:  CALL   10C
....................       } 
....................       delay_ms(10); 
01E6:  MOVLW  0A
01E7:  MOVWF  46
01E8:  CALL   066
01E9:  BSF    03.5
01EA:  GOTO   1C5
....................    } 
.................... } 
....................  
.................... #INT_RDA 
.................... void callbackRDA() { 
*
0054:  CLRF   47
*
01EB:  SLEEP
....................    int i = 0; 
....................    while(kbhit()){ 
*
0055:  BTFSS  0C.5
0056:  GOTO   062
....................          receString[i] = getchar(); 
0057:  MOVLW  2F
0058:  ADDWF  47,W
0059:  MOVWF  04
005A:  BCF    03.7
005B:  BTFSS  0C.5
005C:  GOTO   05B
005D:  MOVF   1A,W
005E:  MOVWF  00
....................          i=i+1; 
005F:  MOVLW  01
0060:  ADDWF  47,F
0061:  GOTO   055
....................       } 
0062:  BCF    0C.5
0063:  BCF    0A.3
0064:  BCF    0A.4
0065:  GOTO   02D
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 2CE1   XT NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
